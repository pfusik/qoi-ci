// QOI.ci - encoder and decoder of the "Quite OK Image" format
//
// Copyright (C) 2021 Piotr Fusik
//
// MIT License:
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

/// QOI color space metadata.
/// Saved in the file header, but doesn't affect encoding or decoding in any way.
public static class QOIColorspace
{
	/// sRGBA.
	public const int Srgb = 0x00;
	/// sRGB with linear alpha.
	public const int SrgbLinearAlpha = 0x01;
	/// Linear RGBA.
	public const int Linear = 0x0f;
}

/// Encoder of the "Quite OK Image" (QOI) format.
/// Losslessly compresses an image to a byte array.
public class QOIEncoder
{
	internal const int HeaderSize = 14;
	internal const int PaddingSize = 4;

	byte[]# Encoded;
	int EncodedSize;

	/// Constructs the encoder.
	/// The encoder can be used for several images, one after another.
	public QOIEncoder()
	{
	}

	/// Determines if an image of given size can be encoded.
	public static bool CanEncode(
		/// Image width in pixels.
		int width,
		/// Image height in pixels.
		int height,
		/// Whether the image has the alpha channel (transparency).
		bool alpha)
		=> width > 0 && height > 0 && height <= (0x7fffffff - HeaderSize - PaddingSize) / width / (alpha ? 5  : 4);

	/// Encodes the given image.
	/// Returns `true` if encoded successfully.
	public bool Encode!(
		/// Image width in pixels.
		int width,
		/// Image height in pixels.
		int height,
		/// Pixels of the image, top-down, left-to-right.
		/// Each pixel is a 32-bit integer 0xAARRGGBB.
		int[] pixels,
		/// `false` specifies that all pixels are opaque. High bytes of `pixels` elements are ignored then.
		bool alpha,
		/// Specifies the color space. See `QOIColorspace`.
		int colorspace)
	{
		if (pixels == null || !CanEncode(width, height, alpha))
			return false;
		int pixelsSize = width * height;
		byte[]# encoded = new byte[HeaderSize + pixelsSize * (alpha ? 5 : 4) + PaddingSize];
		encoded[0] = 'q';
		encoded[1] = 'o';
		encoded[2] = 'i';
		encoded[3] = 'f';
		encoded[4] = width >> 24;
		encoded[5] = width >> 16 & 0xff;
		encoded[6] = width >> 8 & 0xff;
		encoded[7] = width & 0xff;
		encoded[8] = height >> 24;
		encoded[9] = height >> 16 & 0xff;
		encoded[10] = height >> 8 & 0xff;
		encoded[11] = height & 0xff;
		encoded[12] = alpha ? 4 : 3;
		encoded[13] = colorspace;

		int[64] index = 0;
		int encodedOffset = HeaderSize;
		int lastPixel = 0xff << 24;
		int run = 0;
		for (int pixelsOffset = 0; pixelsOffset < pixelsSize; ) {
			int pixel = pixels[pixelsOffset++];
			if (!alpha)
				pixel |= 0xff << 24;
			if (pixel == lastPixel)
				run++;
			if (run > 0 && (pixel != lastPixel || run == 0x2020 || pixelsOffset >= pixelsSize)) {
				if (run <= 32)
					encoded[encodedOffset++] = 0x40 + run - 1;
				else {
					run -= 33;
					encoded[encodedOffset++] = 0x60 + (run >> 8);
					encoded[encodedOffset++] = run & 0xff;
				}
				run = 0;
			}
			if (pixel != lastPixel) {
				int indexOffset = ((pixel >> 24) ^ (pixel >> 16) ^ (pixel >> 8) ^ pixel) & 0x3f;
				if (pixel == index[indexOffset])
					encoded[encodedOffset++] = indexOffset;
				else {
					index[indexOffset] = pixel;
					int r = pixel >> 16 & 0xff;
					int g = pixel >> 8 & 0xff;
					int b = pixel & 0xff;
					int a = pixel >> 24 & 0xff;
					int dr = r - (lastPixel >> 16 & 0xff);
					int dg = g - (lastPixel >> 8 & 0xff);
					int db = b - (lastPixel & 0xff);
					int da = a - (lastPixel >> 24 & 0xff);
					if (dr >= -16 && dr <= 15
					 && dg >= -16 && dg <= 15
					 && db >= -16 && db <= 15
					 && da >= -16 && da <= 15) {
						if (da == 0
						 && dr >= -2 && dr <= 1
						 && dg >= -2 && dg <= 1
						 && db >= -2 && db <= 1)
							encoded[encodedOffset++] = 0x80 + (2 << 4) + (2 << 2) + 2 + (dr << 4) + (dg << 2) + db;
						else if (da == 0
						 && dg >= -8 && dg <= 7
						 && db >= -8 && db <= 7) {
							encoded[encodedOffset++] = 0xc0 + 16 + dr;
							encoded[encodedOffset++] = (8 << 4) + 8 + (dg << 4) + db;
						}
						else {
							dr += 16;
							encoded[encodedOffset++] = 0xe0 + (dr >> 1);
							db += 16;
							encoded[encodedOffset++] = ((dr & 1) << 7) + (dg + 16 << 2) + (db >> 3);
							encoded[encodedOffset++] = ((db & 7) << 5) + da + 16;
						}
					}
					else {
						encoded[encodedOffset++] = 0xf0 | (dr != 0 ? 8 : 0) | (dg != 0 ? 4 : 0) | (db != 0 ? 2 : 0) | (da != 0 ? 1 : 0);
						if (dr != 0)
							encoded[encodedOffset++] = r;
						if (dg != 0)
							encoded[encodedOffset++] = g;
						if (db != 0)
							encoded[encodedOffset++] = b;
						if (da != 0)
							encoded[encodedOffset++] = a;
					}
				}
				lastPixel = pixel;
			}
		}

		encoded.Fill(0, encodedOffset, PaddingSize);
		Encoded = encoded;
		EncodedSize = encodedOffset + PaddingSize;
		return true;
	}

	/// Returns the encoded file contents.
	/// This method can only be called after `Encode` returned `true`.
	/// The allocated array is usually larger than the encoded data.
	/// Call `GetEncodedSize` to retrieve the number of leading bytes that are significant.
	public byte[] GetEncoded() => Encoded;

	/// Returns the encoded file length.
	public int GetEncodedSize() => EncodedSize;
}

/// Decoder of the "Quite OK Image" (QOI) format.
public class QOIDecoder
{
	int Width;
	int Height;
	int[]# Pixels;
	bool Alpha;
	int Colorspace;

	/// Constructs the decoder.
	/// The decoder can be used for several images, one after another.
	public QOIDecoder()
	{
	}

	/// Decodes the given QOI file contents.
	/// Returns `true` if decoded successfully.
	public bool Decode!(
		/// QOI file contents. Only the first `encodedSize` bytes are accessed.
		byte[] encoded,
		/// QOI file length.
		int encodedSize)
	{
		if (encoded == null
		 || encodedSize < QOIEncoder.HeaderSize + 1 + QOIEncoder.PaddingSize
		 || encoded[0] != 'q' || encoded[1] != 'o' || encoded[2] != 'i' || encoded[3] != 'f')
			return false;
		int width = encoded[4] << 24 | encoded[5] << 16 | encoded[6] << 8 | encoded[7];
		int height = encoded[8] << 24 | encoded[9] << 16 | encoded[10] << 8 | encoded[11];
		if (width <= 0 || height <= 0 || height > 0x7fffffff / width)
			return false;
		int pixelsSize = width * height;
		int[]# pixels = new int[pixelsSize];

		encodedSize -= QOIEncoder.PaddingSize;
		int encodedOffset = QOIEncoder.HeaderSize;
		int[64] index = 0;
		int pixel = 0xff << 24;
		for (int pixelsOffset = 0; pixelsOffset < pixelsSize; ) {
			if (encodedOffset >= encodedSize)
				return false;
			int e = encoded[encodedOffset++];
			if (e < 0x80) {
				if (e < 0x40) // 00iiiiii
					pixels[pixelsOffset++] = pixel = index[e];
				else {
					int run;
					if (e < 0x60) // // 010rrrrr
						run = e - (0x40 - 1);
					else // 011rrrrr rrrrrrrr
						run = 33 + (e - 0x60 << 8) + encoded[encodedOffset++];
					if (pixelsOffset + run > pixelsSize)
						return false;
					pixels.Fill(pixel, pixelsOffset, run);
					pixelsOffset += run;
				}
				continue;
			}
			else if (e < 0xe0) {
				if (e < 0xc0) // 10rrggbb
					pixel = (pixel & 0xff << 24)
						| (pixel + ((e >> 4) - 8 - 2 << 16) & 0xff << 16)
						| (pixel + ((e >> 2 & 3) - 2 << 8) & 0xff << 8)
						| (pixel + ((e & 3) - 2) & 0xff);
				else { // 110rrrrr ggggbbbb
					int d = encoded[encodedOffset++];
					pixel = (pixel & 0xff << 24)
						| (pixel + (e - 0xc0 - 16 << 16) & 0xff << 16)
						| (pixel + ((d >> 4) - 8 << 8) & 0xff << 8)
						| (pixel + ((d & 0xf) - 8) & 0xff);
				}
			}
			else if (e < 0xf0) { // 1110rrrr rgggggbb bbbaaaaa
				e = e << 16 | encoded[encodedOffset] << 8 | encoded[encodedOffset + 1];
				encodedOffset += 2;
				pixel = (pixel + ((e & 0x1f) - 16 << 24) & 0xff << 24)
					| (pixel + ((e >> 15) - 0x1c0 - 16 << 16) & 0xff << 16)
					| (pixel + ((e >> 10 & 0x1f) - 16 << 8) & 0xff << 8)
					| (pixel + (e >> 5 & 0x1f) - 16 & 0xff);
			}
			else { // 1111rgba [rrrrrrrr] [gggggggg] [bbbbbbbb] [aaaaaaaa]
				if ((e & 8) != 0)
					pixel = (pixel & ~(0xff << 16)) | encoded[encodedOffset++] << 16;
				if ((e & 4) != 0)
					pixel = (pixel & ~(0xff << 8)) | encoded[encodedOffset++] << 8;
				if ((e & 2) != 0)
					pixel = (pixel & ~0xff) | encoded[encodedOffset++];
				if ((e & 1) != 0)
					pixel = (pixel & ~(0xff << 24)) | encoded[encodedOffset++] << 24;
			}
			pixels[pixelsOffset++] = index[((pixel >> 24) ^ (pixel >> 16) ^ (pixel >> 8) ^ pixel) & 0x3f] = pixel;
		}
		if (encodedOffset != encodedSize)
			return false;

		Width = width;
		Height = height;
		Pixels = pixels;
		Alpha = encoded[12] == 4;
		Colorspace = encoded[13];
		return true;
	}

	/// Returns the width of the decoded image in pixels.
	public int GetWidth() => Width;

	/// Returns the height of the decoded image in pixels.
	public int GetHeight() => Height;

	/// Returns the pixels of the decoded image, top-down, left-to-right.
	/// Each pixel is a 32-bit integer 0xAARRGGBB.
	public int[] GetPixels() => Pixels;

	/// Returns the information about the alpha channel from the file header.
	public bool GetAlpha() => Alpha;

	/// Returns the color space information from the file header.
	/// See `QOIColorspace`.
	public int GetColorspace() => Colorspace;
}
